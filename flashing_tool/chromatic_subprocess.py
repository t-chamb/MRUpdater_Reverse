PycBuffer::getByte(): Unexpected end of stream
# Source Generated with Decompyle++
# File: chromatic_subprocess.pyc (Python 3.10)

import io
import json
import logging
import os
from pathlib import Path
import re
import subprocess
import sys
import tempfile
import time
import zipfile
from argparse import Namespace
from contextlib import redirect_stdout
from enum import IntEnum
from typing import Callable
import espefuse.efuse.esp32
esp32_efuse = esp32
efuse
import serial
import yaml
from PySide6.QtCore import QObject, QThread, Signal
from espefuse.efuse.esp32.operations import set_flash_voltage
from esptool import write_flash
from flashing_tool.constants import SUBPROCESS_FLAGS
from flashing_tool.esp_util import create_address_filename_pair
from flashing_tool.logging import IntervalSamplingFilter
from flashing_tool.s3_wrapper import S3Wrapper
from flashing_tool.util import CartClinicFirmwarePackage, ChromaticFirmwarePackage, MRUpdaterManifestData, S3FirmwareInfo, resolve_path
flashing_tool_logger = logging.getLogger('mrupdater')

class OpenFPGALoaderResult(IntEnum):
    SUCCESS = 0
    TIMEOUT = -1
    FAIL = -3
    SKIP = -4


class FlashingToolOutputBuffer(io.StringIO):
    '''
    I/O class to buffer and parse the output generated
    by both esptool and openFPGALoader

    The primary function of this class is to extract the flashing
    progress information from the output generated by the respective
    flashing tools (openFPGALoader and esptool)
    '''
    
    def __init__(self, callback = None, parser = None, print_prefix = None, initial_value = ('', '', '\n'), newline = ('callback', Callable, 'parser', Callable, 'print_prefix', str, 'initial_value', str, 'newline', str)):
        io.StringIO.__init__(self, initial_value, newline)
        self._on_flashing_progress_callback = callback
        self._parser = parser
        self.print_prefix = print_prefix

    
    def write(self = None, s = None):
        self.on_flashing_progress(s)
        return super().write(s)

    
    def on_flashing_progress(self = None, line = None):
        '''Parses the flashing progress information

        If no progress information is found, the callback function is
        not invoked
        :param line:
        :return:
        '''
        if line:
            print(f'''{self.print_prefix}{line}''', sys.stderr, '', **('file', 'end'))
        progress = self._parser(line)
        if progress:
            self._on_flashing_progress_callback(progress)
            return None

    __classcell__ = None


class WaitForTime(QThread):
    finished = Signal(int)
    
    def __init__(self = None, timeout = None, parent = None):
        super().__init__(parent)
        self.timeout = timeout

    
    def run(self):
        time.sleep(self.timeout)
        self.finished.emit(0)

    __classcell__ = None


class WaitForInterval(QThread):
    update_signal = Signal(bool)
    
    def __init__(self = None, interval = None, parent = None):
        super().__init__(parent)
        self.running = True
        self.interval = interval

    
    def run(self):
